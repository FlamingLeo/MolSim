// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulationXSD.h"

// ArgsType
//

const ArgsType::StartTimeOptional &ArgsType::startTime() const { return this->startTime_; }

ArgsType::StartTimeOptional &ArgsType::startTime() { return this->startTime_; }

void ArgsType::startTime(const StartTimeType &x) { this->startTime_.set(x); }

void ArgsType::startTime(const StartTimeOptional &x) { this->startTime_ = x; }

const ArgsType::EndTimeOptional &ArgsType::endTime() const { return this->endTime_; }

ArgsType::EndTimeOptional &ArgsType::endTime() { return this->endTime_; }

void ArgsType::endTime(const EndTimeType &x) { this->endTime_.set(x); }

void ArgsType::endTime(const EndTimeOptional &x) { this->endTime_ = x; }

const ArgsType::Delta_tOptional &ArgsType::delta_t() const { return this->delta_t_; }

ArgsType::Delta_tOptional &ArgsType::delta_t() { return this->delta_t_; }

void ArgsType::delta_t(const Delta_tType &x) { this->delta_t_.set(x); }

void ArgsType::delta_t(const Delta_tOptional &x) { this->delta_t_ = x; }

const ArgsType::FrequencyOptional &ArgsType::frequency() const { return this->frequency_; }

ArgsType::FrequencyOptional &ArgsType::frequency() { return this->frequency_; }

void ArgsType::frequency(const FrequencyType &x) { this->frequency_.set(x); }

void ArgsType::frequency(const FrequencyOptional &x) { this->frequency_ = x; }

const ArgsType::BasenameOptional &ArgsType::basename() const { return this->basename_; }

ArgsType::BasenameOptional &ArgsType::basename() { return this->basename_; }

void ArgsType::basename(const BasenameType &x) { this->basename_.set(x); }

void ArgsType::basename(const BasenameOptional &x) { this->basename_ = x; }

void ArgsType::basename(::std::unique_ptr<BasenameType> x) { this->basename_.set(std::move(x)); }

const ArgsType::OutputOptional &ArgsType::output() const { return this->output_; }

ArgsType::OutputOptional &ArgsType::output() { return this->output_; }

void ArgsType::output(const OutputType &x) { this->output_.set(x); }

void ArgsType::output(const OutputOptional &x) { this->output_ = x; }

void ArgsType::output(::std::unique_ptr<OutputType> x) { this->output_.set(std::move(x)); }

const ArgsType::DomainSizeOptional &ArgsType::domainSize() const { return this->domainSize_; }

ArgsType::DomainSizeOptional &ArgsType::domainSize() { return this->domainSize_; }

void ArgsType::domainSize(const DomainSizeType &x) { this->domainSize_.set(x); }

void ArgsType::domainSize(const DomainSizeOptional &x) { this->domainSize_ = x; }

void ArgsType::domainSize(::std::unique_ptr<DomainSizeType> x) { this->domainSize_.set(std::move(x)); }

const ArgsType::CutoffRadiusOptional &ArgsType::cutoffRadius() const { return this->cutoffRadius_; }

ArgsType::CutoffRadiusOptional &ArgsType::cutoffRadius() { return this->cutoffRadius_; }

void ArgsType::cutoffRadius(const CutoffRadiusType &x) { this->cutoffRadius_.set(x); }

void ArgsType::cutoffRadius(const CutoffRadiusOptional &x) { this->cutoffRadius_ = x; }

const ArgsType::BdConditionsOptional &ArgsType::bdConditions() const { return this->bdConditions_; }

ArgsType::BdConditionsOptional &ArgsType::bdConditions() { return this->bdConditions_; }

void ArgsType::bdConditions(const BdConditionsType &x) { this->bdConditions_.set(x); }

void ArgsType::bdConditions(const BdConditionsOptional &x) { this->bdConditions_ = x; }

void ArgsType::bdConditions(::std::unique_ptr<BdConditionsType> x) { this->bdConditions_.set(std::move(x)); }

const ArgsType::GravityOptional &ArgsType::gravity() const { return this->gravity_; }

ArgsType::GravityOptional &ArgsType::gravity() { return this->gravity_; }

void ArgsType::gravity(const GravityType &x) { this->gravity_.set(x); }

void ArgsType::gravity(const GravityOptional &x) { this->gravity_ = x; }

// BdConditionsType
//

const BdConditionsType::NType &BdConditionsType::n() const { return this->n_.get(); }

BdConditionsType::NType &BdConditionsType::n() { return this->n_.get(); }

void BdConditionsType::n(const NType &x) { this->n_.set(x); }

void BdConditionsType::n(::std::unique_ptr<NType> x) { this->n_.set(std::move(x)); }

const BdConditionsType::SType &BdConditionsType::s() const { return this->s_.get(); }

BdConditionsType::SType &BdConditionsType::s() { return this->s_.get(); }

void BdConditionsType::s(const SType &x) { this->s_.set(x); }

void BdConditionsType::s(::std::unique_ptr<SType> x) { this->s_.set(std::move(x)); }

const BdConditionsType::WType &BdConditionsType::w() const { return this->w_.get(); }

BdConditionsType::WType &BdConditionsType::w() { return this->w_.get(); }

void BdConditionsType::w(const WType &x) { this->w_.set(x); }

void BdConditionsType::w(::std::unique_ptr<WType> x) { this->w_.set(std::move(x)); }

const BdConditionsType::EType &BdConditionsType::e() const { return this->e_.get(); }

BdConditionsType::EType &BdConditionsType::e() { return this->e_.get(); }

void BdConditionsType::e(const EType &x) { this->e_.set(x); }

void BdConditionsType::e(::std::unique_ptr<EType> x) { this->e_.set(std::move(x)); }

const BdConditionsType::AType &BdConditionsType::a() const { return this->a_.get(); }

BdConditionsType::AType &BdConditionsType::a() { return this->a_.get(); }

void BdConditionsType::a(const AType &x) { this->a_.set(x); }

void BdConditionsType::a(::std::unique_ptr<AType> x) { this->a_.set(std::move(x)); }

const BdConditionsType::BType &BdConditionsType::b() const { return this->b_.get(); }

BdConditionsType::BType &BdConditionsType::b() { return this->b_.get(); }

void BdConditionsType::b(const BType &x) { this->b_.set(x); }

void BdConditionsType::b(::std::unique_ptr<BType> x) { this->b_.set(std::move(x)); }

// BoundaryConditionType
//

BoundaryConditionType::BoundaryConditionType(Value v) : ::xml_schema::String(_xsd_BoundaryConditionType_literals_[v]) {}

BoundaryConditionType::BoundaryConditionType(const char *v) : ::xml_schema::String(v) {}

BoundaryConditionType::BoundaryConditionType(const ::std::string &v) : ::xml_schema::String(v) {}

BoundaryConditionType::BoundaryConditionType(const ::xml_schema::String &v) : ::xml_schema::String(v) {}

BoundaryConditionType::BoundaryConditionType(const BoundaryConditionType &v, ::xml_schema::Flags f,
                                             ::xml_schema::Container *c)
    : ::xml_schema::String(v, f, c) {}

BoundaryConditionType &BoundaryConditionType::operator=(Value v) {
    static_cast<::xml_schema::String &>(*this) = ::xml_schema::String(_xsd_BoundaryConditionType_literals_[v]);

    return *this;
}

// PositionType
//

const PositionType::XType &PositionType::x() const { return this->x_.get(); }

PositionType::XType &PositionType::x() { return this->x_.get(); }

void PositionType::x(const XType &x) { this->x_.set(x); }

const PositionType::YType &PositionType::y() const { return this->y_.get(); }

PositionType::YType &PositionType::y() { return this->y_.get(); }

void PositionType::y(const YType &x) { this->y_.set(x); }

const PositionType::ZType &PositionType::z() const { return this->z_.get(); }

PositionType::ZType &PositionType::z() { return this->z_.get(); }

void PositionType::z(const ZType &x) { this->z_.set(x); }

// VelocityType
//

const VelocityType::XType &VelocityType::x() const { return this->x_.get(); }

VelocityType::XType &VelocityType::x() { return this->x_.get(); }

void VelocityType::x(const XType &x) { this->x_.set(x); }

const VelocityType::YType &VelocityType::y() const { return this->y_.get(); }

VelocityType::YType &VelocityType::y() { return this->y_.get(); }

void VelocityType::y(const YType &x) { this->y_.set(x); }

const VelocityType::ZType &VelocityType::z() const { return this->z_.get(); }

VelocityType::ZType &VelocityType::z() { return this->z_.get(); }

void VelocityType::z(const ZType &x) { this->z_.set(x); }

// ForceType
//

const ForceType::XType &ForceType::x() const { return this->x_.get(); }

ForceType::XType &ForceType::x() { return this->x_.get(); }

void ForceType::x(const XType &x) { this->x_.set(x); }

const ForceType::YType &ForceType::y() const { return this->y_.get(); }

ForceType::YType &ForceType::y() { return this->y_.get(); }

void ForceType::y(const YType &x) { this->y_.set(x); }

const ForceType::ZType &ForceType::z() const { return this->z_.get(); }

ForceType::ZType &ForceType::z() { return this->z_.get(); }

void ForceType::z(const ZType &x) { this->z_.set(x); }

// SizeType
//

const SizeType::XType &SizeType::x() const { return this->x_.get(); }

SizeType::XType &SizeType::x() { return this->x_.get(); }

void SizeType::x(const XType &x) { this->x_.set(x); }

const SizeType::YType &SizeType::y() const { return this->y_.get(); }

SizeType::YType &SizeType::y() { return this->y_.get(); }

void SizeType::y(const YType &x) { this->y_.set(x); }

const SizeType::ZType &SizeType::z() const { return this->z_.get(); }

SizeType::ZType &SizeType::z() { return this->z_.get(); }

void SizeType::z(const ZType &x) { this->z_.set(x); }

// CuboidType
//

const CuboidType::PositionType &CuboidType::position() const { return this->position_.get(); }

CuboidType::PositionType &CuboidType::position() { return this->position_.get(); }

void CuboidType::position(const PositionType &x) { this->position_.set(x); }

void CuboidType::position(::std::unique_ptr<PositionType> x) { this->position_.set(std::move(x)); }

const CuboidType::VelocityType &CuboidType::velocity() const { return this->velocity_.get(); }

CuboidType::VelocityType &CuboidType::velocity() { return this->velocity_.get(); }

void CuboidType::velocity(const VelocityType &x) { this->velocity_.set(x); }

void CuboidType::velocity(::std::unique_ptr<VelocityType> x) { this->velocity_.set(std::move(x)); }

const CuboidType::SizeType &CuboidType::size() const { return this->size_.get(); }

CuboidType::SizeType &CuboidType::size() { return this->size_.get(); }

void CuboidType::size(const SizeType &x) { this->size_.set(x); }

void CuboidType::size(::std::unique_ptr<SizeType> x) { this->size_.set(std::move(x)); }

const CuboidType::DistanceType &CuboidType::distance() const { return this->distance_.get(); }

CuboidType::DistanceType &CuboidType::distance() { return this->distance_.get(); }

void CuboidType::distance(const DistanceType &x) { this->distance_.set(x); }

const CuboidType::MassType &CuboidType::mass() const { return this->mass_.get(); }

CuboidType::MassType &CuboidType::mass() { return this->mass_.get(); }

void CuboidType::mass(const MassType &x) { this->mass_.set(x); }

const CuboidType::TypeOptional &CuboidType::type() const { return this->type_; }

CuboidType::TypeOptional &CuboidType::type() { return this->type_; }

void CuboidType::type(const TypeType &x) { this->type_.set(x); }

void CuboidType::type(const TypeOptional &x) { this->type_ = x; }

const CuboidType::EpsilonOptional &CuboidType::epsilon() const { return this->epsilon_; }

CuboidType::EpsilonOptional &CuboidType::epsilon() { return this->epsilon_; }

void CuboidType::epsilon(const EpsilonType &x) { this->epsilon_.set(x); }

void CuboidType::epsilon(const EpsilonOptional &x) { this->epsilon_ = x; }

const CuboidType::SigmaOptional &CuboidType::sigma() const { return this->sigma_; }

CuboidType::SigmaOptional &CuboidType::sigma() { return this->sigma_; }

void CuboidType::sigma(const SigmaType &x) { this->sigma_.set(x); }

void CuboidType::sigma(const SigmaOptional &x) { this->sigma_ = x; }

// ParticleType
//

const ParticleType::PositionType &ParticleType::position() const { return this->position_.get(); }

ParticleType::PositionType &ParticleType::position() { return this->position_.get(); }

void ParticleType::position(const PositionType &x) { this->position_.set(x); }

void ParticleType::position(::std::unique_ptr<PositionType> x) { this->position_.set(std::move(x)); }

const ParticleType::VelocityType &ParticleType::velocity() const { return this->velocity_.get(); }

ParticleType::VelocityType &ParticleType::velocity() { return this->velocity_.get(); }

void ParticleType::velocity(const VelocityType &x) { this->velocity_.set(x); }

void ParticleType::velocity(::std::unique_ptr<VelocityType> x) { this->velocity_.set(std::move(x)); }

const ParticleType::ForceOptional &ParticleType::force() const { return this->force_; }

ParticleType::ForceOptional &ParticleType::force() { return this->force_; }

void ParticleType::force(const ForceType &x) { this->force_.set(x); }

void ParticleType::force(const ForceOptional &x) { this->force_ = x; }

void ParticleType::force(::std::unique_ptr<ForceType> x) { this->force_.set(std::move(x)); }

const ParticleType::OldForceOptional &ParticleType::oldForce() const { return this->oldForce_; }

ParticleType::OldForceOptional &ParticleType::oldForce() { return this->oldForce_; }

void ParticleType::oldForce(const OldForceType &x) { this->oldForce_.set(x); }

void ParticleType::oldForce(const OldForceOptional &x) { this->oldForce_ = x; }

void ParticleType::oldForce(::std::unique_ptr<OldForceType> x) { this->oldForce_.set(std::move(x)); }

const ParticleType::MassType &ParticleType::mass() const { return this->mass_.get(); }

ParticleType::MassType &ParticleType::mass() { return this->mass_.get(); }

void ParticleType::mass(const MassType &x) { this->mass_.set(x); }

const ParticleType::TypeOptional &ParticleType::type() const { return this->type_; }

ParticleType::TypeOptional &ParticleType::type() { return this->type_; }

void ParticleType::type(const TypeType &x) { this->type_.set(x); }

void ParticleType::type(const TypeOptional &x) { this->type_ = x; }

const ParticleType::EpsilonOptional &ParticleType::epsilon() const { return this->epsilon_; }

ParticleType::EpsilonOptional &ParticleType::epsilon() { return this->epsilon_; }

void ParticleType::epsilon(const EpsilonType &x) { this->epsilon_.set(x); }

void ParticleType::epsilon(const EpsilonOptional &x) { this->epsilon_ = x; }

const ParticleType::SigmaOptional &ParticleType::sigma() const { return this->sigma_; }

ParticleType::SigmaOptional &ParticleType::sigma() { return this->sigma_; }

void ParticleType::sigma(const SigmaType &x) { this->sigma_.set(x); }

void ParticleType::sigma(const SigmaOptional &x) { this->sigma_ = x; }

const ParticleType::CellIndexOptional &ParticleType::cellIndex() const { return this->cellIndex_; }

ParticleType::CellIndexOptional &ParticleType::cellIndex() { return this->cellIndex_; }

void ParticleType::cellIndex(const CellIndexType &x) { this->cellIndex_.set(x); }

void ParticleType::cellIndex(const CellIndexOptional &x) { this->cellIndex_ = x; }

// DiscType
//

const DiscType::PositionType &DiscType::position() const { return this->position_.get(); }

DiscType::PositionType &DiscType::position() { return this->position_.get(); }

void DiscType::position(const PositionType &x) { this->position_.set(x); }

void DiscType::position(::std::unique_ptr<PositionType> x) { this->position_.set(std::move(x)); }

const DiscType::VelocityType &DiscType::velocity() const { return this->velocity_.get(); }

DiscType::VelocityType &DiscType::velocity() { return this->velocity_.get(); }

void DiscType::velocity(const VelocityType &x) { this->velocity_.set(x); }

void DiscType::velocity(::std::unique_ptr<VelocityType> x) { this->velocity_.set(std::move(x)); }

const DiscType::RadiusType &DiscType::radius() const { return this->radius_.get(); }

DiscType::RadiusType &DiscType::radius() { return this->radius_.get(); }

void DiscType::radius(const RadiusType &x) { this->radius_.set(x); }

const DiscType::DistanceType &DiscType::distance() const { return this->distance_.get(); }

DiscType::DistanceType &DiscType::distance() { return this->distance_.get(); }

void DiscType::distance(const DistanceType &x) { this->distance_.set(x); }

const DiscType::MassType &DiscType::mass() const { return this->mass_.get(); }

DiscType::MassType &DiscType::mass() { return this->mass_.get(); }

void DiscType::mass(const MassType &x) { this->mass_.set(x); }

const DiscType::TypeOptional &DiscType::type() const { return this->type_; }

DiscType::TypeOptional &DiscType::type() { return this->type_; }

void DiscType::type(const TypeType &x) { this->type_.set(x); }

void DiscType::type(const TypeOptional &x) { this->type_ = x; }

const DiscType::EpsilonOptional &DiscType::epsilon() const { return this->epsilon_; }

DiscType::EpsilonOptional &DiscType::epsilon() { return this->epsilon_; }

void DiscType::epsilon(const EpsilonType &x) { this->epsilon_.set(x); }

void DiscType::epsilon(const EpsilonOptional &x) { this->epsilon_ = x; }

const DiscType::SigmaOptional &DiscType::sigma() const { return this->sigma_; }

DiscType::SigmaOptional &DiscType::sigma() { return this->sigma_; }

void DiscType::sigma(const SigmaType &x) { this->sigma_.set(x); }

void DiscType::sigma(const SigmaOptional &x) { this->sigma_ = x; }

// ObjectsType
//

const ObjectsType::CuboidSequence &ObjectsType::cuboid() const { return this->cuboid_; }

ObjectsType::CuboidSequence &ObjectsType::cuboid() { return this->cuboid_; }

void ObjectsType::cuboid(const CuboidSequence &s) { this->cuboid_ = s; }

const ObjectsType::ParticleSequence &ObjectsType::particle() const { return this->particle_; }

ObjectsType::ParticleSequence &ObjectsType::particle() { return this->particle_; }

void ObjectsType::particle(const ParticleSequence &s) { this->particle_ = s; }

const ObjectsType::DiscSequence &ObjectsType::disc() const { return this->disc_; }

ObjectsType::DiscSequence &ObjectsType::disc() { return this->disc_; }

void ObjectsType::disc(const DiscSequence &s) { this->disc_ = s; }

// SimType
//

const SimType::ArgsOptional &SimType::args() const { return this->args_; }

SimType::ArgsOptional &SimType::args() { return this->args_; }

void SimType::args(const ArgsType &x) { this->args_.set(x); }

void SimType::args(const ArgsOptional &x) { this->args_ = x; }

void SimType::args(::std::unique_ptr<ArgsType> x) { this->args_.set(std::move(x)); }

const SimType::TypeType &SimType::type() const { return this->type_.get(); }

SimType::TypeType &SimType::type() { return this->type_.get(); }

void SimType::type(const TypeType &x) { this->type_.set(x); }

void SimType::type(::std::unique_ptr<TypeType> x) { this->type_.set(std::move(x)); }

const SimType::LinkedCellsOptional &SimType::linkedCells() const { return this->linkedCells_; }

SimType::LinkedCellsOptional &SimType::linkedCells() { return this->linkedCells_; }

void SimType::linkedCells(const LinkedCellsType &x) { this->linkedCells_.set(x); }

void SimType::linkedCells(const LinkedCellsOptional &x) { this->linkedCells_ = x; }

const SimType::ObjectsType &SimType::objects() const { return this->objects_.get(); }

SimType::ObjectsType &SimType::objects() { return this->objects_.get(); }

void SimType::objects(const ObjectsType &x) { this->objects_.set(x); }

void SimType::objects(::std::unique_ptr<ObjectsType> x) { this->objects_.set(std::move(x)); }

const SimType::TotalParticlesOptional &SimType::totalParticles() const { return this->totalParticles_; }

SimType::TotalParticlesOptional &SimType::totalParticles() { return this->totalParticles_; }

void SimType::totalParticles(const TotalParticlesType &x) { this->totalParticles_.set(x); }

void SimType::totalParticles(const TotalParticlesOptional &x) { this->totalParticles_ = x; }

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ArgsType
//

ArgsType::ArgsType()
    : ::xml_schema::Type(), startTime_(this), endTime_(this), delta_t_(this), frequency_(this), basename_(this),
      output_(this), domainSize_(this), cutoffRadius_(this), bdConditions_(this), gravity_(this) {}

ArgsType::ArgsType(const ArgsType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), startTime_(x.startTime_, f, this), endTime_(x.endTime_, f, this),
      delta_t_(x.delta_t_, f, this), frequency_(x.frequency_, f, this), basename_(x.basename_, f, this),
      output_(x.output_, f, this), domainSize_(x.domainSize_, f, this), cutoffRadius_(x.cutoffRadius_, f, this),
      bdConditions_(x.bdConditions_, f, this), gravity_(x.gravity_, f, this) {}

ArgsType::ArgsType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), startTime_(this), endTime_(this), delta_t_(this),
      frequency_(this), basename_(this), output_(this), domainSize_(this), cutoffRadius_(this), bdConditions_(this),
      gravity_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void ArgsType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // startTime
        //
        if (n.name() == "startTime" && n.namespace_().empty()) {
            if (!this->startTime_) {
                this->startTime_.set(StartTimeTraits::create(i, f, this));
                continue;
            }
        }

        // endTime
        //
        if (n.name() == "endTime" && n.namespace_().empty()) {
            if (!this->endTime_) {
                this->endTime_.set(EndTimeTraits::create(i, f, this));
                continue;
            }
        }

        // delta_t
        //
        if (n.name() == "delta_t" && n.namespace_().empty()) {
            if (!this->delta_t_) {
                this->delta_t_.set(Delta_tTraits::create(i, f, this));
                continue;
            }
        }

        // frequency
        //
        if (n.name() == "frequency" && n.namespace_().empty()) {
            if (!this->frequency_) {
                this->frequency_.set(FrequencyTraits::create(i, f, this));
                continue;
            }
        }

        // basename
        //
        if (n.name() == "basename" && n.namespace_().empty()) {
            ::std::unique_ptr<BasenameType> r(BasenameTraits::create(i, f, this));

            if (!this->basename_) {
                this->basename_.set(::std::move(r));
                continue;
            }
        }

        // output
        //
        if (n.name() == "output" && n.namespace_().empty()) {
            ::std::unique_ptr<OutputType> r(OutputTraits::create(i, f, this));

            if (!this->output_) {
                this->output_.set(::std::move(r));
                continue;
            }
        }

        // domainSize
        //
        if (n.name() == "domainSize" && n.namespace_().empty()) {
            ::std::unique_ptr<DomainSizeType> r(DomainSizeTraits::create(i, f, this));

            if (!this->domainSize_) {
                this->domainSize_.set(::std::move(r));
                continue;
            }
        }

        // cutoffRadius
        //
        if (n.name() == "cutoffRadius" && n.namespace_().empty()) {
            if (!this->cutoffRadius_) {
                this->cutoffRadius_.set(CutoffRadiusTraits::create(i, f, this));
                continue;
            }
        }

        // bdConditions
        //
        if (n.name() == "bdConditions" && n.namespace_().empty()) {
            ::std::unique_ptr<BdConditionsType> r(BdConditionsTraits::create(i, f, this));

            if (!this->bdConditions_) {
                this->bdConditions_.set(::std::move(r));
                continue;
            }
        }

        // gravity
        //
        if (n.name() == "gravity" && n.namespace_().empty()) {
            if (!this->gravity_) {
                this->gravity_.set(GravityTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }
}

ArgsType *ArgsType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class ArgsType(*this, f, c);
}

ArgsType &ArgsType::operator=(const ArgsType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->startTime_ = x.startTime_;
        this->endTime_ = x.endTime_;
        this->delta_t_ = x.delta_t_;
        this->frequency_ = x.frequency_;
        this->basename_ = x.basename_;
        this->output_ = x.output_;
        this->domainSize_ = x.domainSize_;
        this->cutoffRadius_ = x.cutoffRadius_;
        this->bdConditions_ = x.bdConditions_;
        this->gravity_ = x.gravity_;
    }

    return *this;
}

ArgsType::~ArgsType() {}

// BdConditionsType
//

BdConditionsType::BdConditionsType(const NType &n, const SType &s, const WType &w, const EType &e, const AType &a,
                                   const BType &b)
    : ::xml_schema::Type(), n_(n, this), s_(s, this), w_(w, this), e_(e, this), a_(a, this), b_(b, this) {}

BdConditionsType::BdConditionsType(const BdConditionsType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), n_(x.n_, f, this), s_(x.s_, f, this), w_(x.w_, f, this), e_(x.e_, f, this),
      a_(x.a_, f, this), b_(x.b_, f, this) {}

BdConditionsType::BdConditionsType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), n_(this), s_(this), w_(this), e_(this), a_(this),
      b_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void BdConditionsType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // n
        //
        if (n.name() == "n" && n.namespace_().empty()) {
            ::std::unique_ptr<NType> r(NTraits::create(i, f, this));

            if (!n_.present()) {
                this->n_.set(::std::move(r));
                continue;
            }
        }

        // s
        //
        if (n.name() == "s" && n.namespace_().empty()) {
            ::std::unique_ptr<SType> r(STraits::create(i, f, this));

            if (!s_.present()) {
                this->s_.set(::std::move(r));
                continue;
            }
        }

        // w
        //
        if (n.name() == "w" && n.namespace_().empty()) {
            ::std::unique_ptr<WType> r(WTraits::create(i, f, this));

            if (!w_.present()) {
                this->w_.set(::std::move(r));
                continue;
            }
        }

        // e
        //
        if (n.name() == "e" && n.namespace_().empty()) {
            ::std::unique_ptr<EType> r(ETraits::create(i, f, this));

            if (!e_.present()) {
                this->e_.set(::std::move(r));
                continue;
            }
        }

        // a
        //
        if (n.name() == "a" && n.namespace_().empty()) {
            ::std::unique_ptr<AType> r(ATraits::create(i, f, this));

            if (!a_.present()) {
                this->a_.set(::std::move(r));
                continue;
            }
        }

        // b
        //
        if (n.name() == "b" && n.namespace_().empty()) {
            ::std::unique_ptr<BType> r(BTraits::create(i, f, this));

            if (!b_.present()) {
                this->b_.set(::std::move(r));
                continue;
            }
        }

        break;
    }

    if (!n_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("n", "");
    }

    if (!s_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("s", "");
    }

    if (!w_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("w", "");
    }

    if (!e_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("e", "");
    }

    if (!a_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("a", "");
    }

    if (!b_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("b", "");
    }
}

BdConditionsType *BdConditionsType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class BdConditionsType(*this, f, c);
}

BdConditionsType &BdConditionsType::operator=(const BdConditionsType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->n_ = x.n_;
        this->s_ = x.s_;
        this->w_ = x.w_;
        this->e_ = x.e_;
        this->a_ = x.a_;
        this->b_ = x.b_;
    }

    return *this;
}

BdConditionsType::~BdConditionsType() {}

// BoundaryConditionType
//

BoundaryConditionType::BoundaryConditionType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f,
                                             ::xml_schema::Container *c)
    : ::xml_schema::String(e, f, c) {
    _xsd_BoundaryConditionType_convert();
}

BoundaryConditionType::BoundaryConditionType(const ::xercesc::DOMAttr &a, ::xml_schema::Flags f,
                                             ::xml_schema::Container *c)
    : ::xml_schema::String(a, f, c) {
    _xsd_BoundaryConditionType_convert();
}

BoundaryConditionType::BoundaryConditionType(const ::std::string &s, const ::xercesc::DOMElement *e,
                                             ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::String(s, e, f, c) {
    _xsd_BoundaryConditionType_convert();
}

BoundaryConditionType *BoundaryConditionType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class BoundaryConditionType(*this, f, c);
}

BoundaryConditionType::Value BoundaryConditionType::_xsd_BoundaryConditionType_convert() const {
    ::xsd::cxx::tree::enum_comparator<char> c(_xsd_BoundaryConditionType_literals_);
    const Value *i(
        ::std::lower_bound(_xsd_BoundaryConditionType_indexes_, _xsd_BoundaryConditionType_indexes_ + 2, *this, c));

    if (i == _xsd_BoundaryConditionType_indexes_ + 2 || _xsd_BoundaryConditionType_literals_[*i] != *this) {
        throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
    }

    return *i;
}

const char *const BoundaryConditionType::_xsd_BoundaryConditionType_literals_[2] = {"outflow", "reflective"};

const BoundaryConditionType::Value BoundaryConditionType::_xsd_BoundaryConditionType_indexes_[2] = {
    ::BoundaryConditionType::outflow, ::BoundaryConditionType::reflective};

// PositionType
//

PositionType::PositionType(const XType &x, const YType &y, const ZType &z)
    : ::xml_schema::Type(), x_(x, this), y_(y, this), z_(z, this) {}

PositionType::PositionType(const PositionType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), x_(x.x_, f, this), y_(x.y_, f, this), z_(x.z_, f, this) {}

PositionType::PositionType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), x_(this), y_(this), z_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void PositionType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // x
        //
        if (n.name() == "x" && n.namespace_().empty()) {
            if (!x_.present()) {
                this->x_.set(XTraits::create(i, f, this));
                continue;
            }
        }

        // y
        //
        if (n.name() == "y" && n.namespace_().empty()) {
            if (!y_.present()) {
                this->y_.set(YTraits::create(i, f, this));
                continue;
            }
        }

        // z
        //
        if (n.name() == "z" && n.namespace_().empty()) {
            if (!z_.present()) {
                this->z_.set(ZTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!x_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("x", "");
    }

    if (!y_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("y", "");
    }

    if (!z_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("z", "");
    }
}

PositionType *PositionType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class PositionType(*this, f, c);
}

PositionType &PositionType::operator=(const PositionType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
    }

    return *this;
}

PositionType::~PositionType() {}

// VelocityType
//

VelocityType::VelocityType(const XType &x, const YType &y, const ZType &z)
    : ::xml_schema::Type(), x_(x, this), y_(y, this), z_(z, this) {}

VelocityType::VelocityType(const VelocityType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), x_(x.x_, f, this), y_(x.y_, f, this), z_(x.z_, f, this) {}

VelocityType::VelocityType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), x_(this), y_(this), z_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void VelocityType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // x
        //
        if (n.name() == "x" && n.namespace_().empty()) {
            if (!x_.present()) {
                this->x_.set(XTraits::create(i, f, this));
                continue;
            }
        }

        // y
        //
        if (n.name() == "y" && n.namespace_().empty()) {
            if (!y_.present()) {
                this->y_.set(YTraits::create(i, f, this));
                continue;
            }
        }

        // z
        //
        if (n.name() == "z" && n.namespace_().empty()) {
            if (!z_.present()) {
                this->z_.set(ZTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!x_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("x", "");
    }

    if (!y_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("y", "");
    }

    if (!z_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("z", "");
    }
}

VelocityType *VelocityType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class VelocityType(*this, f, c);
}

VelocityType &VelocityType::operator=(const VelocityType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
    }

    return *this;
}

VelocityType::~VelocityType() {}

// ForceType
//

ForceType::ForceType(const XType &x, const YType &y, const ZType &z)
    : ::xml_schema::Type(), x_(x, this), y_(y, this), z_(z, this) {}

ForceType::ForceType(const ForceType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), x_(x.x_, f, this), y_(x.y_, f, this), z_(x.z_, f, this) {}

ForceType::ForceType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), x_(this), y_(this), z_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void ForceType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // x
        //
        if (n.name() == "x" && n.namespace_().empty()) {
            if (!x_.present()) {
                this->x_.set(XTraits::create(i, f, this));
                continue;
            }
        }

        // y
        //
        if (n.name() == "y" && n.namespace_().empty()) {
            if (!y_.present()) {
                this->y_.set(YTraits::create(i, f, this));
                continue;
            }
        }

        // z
        //
        if (n.name() == "z" && n.namespace_().empty()) {
            if (!z_.present()) {
                this->z_.set(ZTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!x_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("x", "");
    }

    if (!y_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("y", "");
    }

    if (!z_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("z", "");
    }
}

ForceType *ForceType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class ForceType(*this, f, c);
}

ForceType &ForceType::operator=(const ForceType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
    }

    return *this;
}

ForceType::~ForceType() {}

// SizeType
//

SizeType::SizeType(const XType &x, const YType &y, const ZType &z)
    : ::xml_schema::Type(), x_(x, this), y_(y, this), z_(z, this) {}

SizeType::SizeType(const SizeType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), x_(x.x_, f, this), y_(x.y_, f, this), z_(x.z_, f, this) {}

SizeType::SizeType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), x_(this), y_(this), z_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void SizeType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // x
        //
        if (n.name() == "x" && n.namespace_().empty()) {
            if (!x_.present()) {
                this->x_.set(XTraits::create(i, f, this));
                continue;
            }
        }

        // y
        //
        if (n.name() == "y" && n.namespace_().empty()) {
            if (!y_.present()) {
                this->y_.set(YTraits::create(i, f, this));
                continue;
            }
        }

        // z
        //
        if (n.name() == "z" && n.namespace_().empty()) {
            if (!z_.present()) {
                this->z_.set(ZTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!x_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("x", "");
    }

    if (!y_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("y", "");
    }

    if (!z_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("z", "");
    }
}

SizeType *SizeType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class SizeType(*this, f, c);
}

SizeType &SizeType::operator=(const SizeType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
    }

    return *this;
}

SizeType::~SizeType() {}

// CuboidType
//

CuboidType::CuboidType(const PositionType &position, const VelocityType &velocity, const SizeType &size,
                       const DistanceType &distance, const MassType &mass)
    : ::xml_schema::Type(), position_(position, this), velocity_(velocity, this), size_(size, this),
      distance_(distance, this), mass_(mass, this), type_(this), epsilon_(this), sigma_(this) {}

CuboidType::CuboidType(::std::unique_ptr<PositionType> position, ::std::unique_ptr<VelocityType> velocity,
                       ::std::unique_ptr<SizeType> size, const DistanceType &distance, const MassType &mass)
    : ::xml_schema::Type(), position_(std::move(position), this), velocity_(std::move(velocity), this),
      size_(std::move(size), this), distance_(distance, this), mass_(mass, this), type_(this), epsilon_(this),
      sigma_(this) {}

CuboidType::CuboidType(const CuboidType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), position_(x.position_, f, this), velocity_(x.velocity_, f, this),
      size_(x.size_, f, this), distance_(x.distance_, f, this), mass_(x.mass_, f, this), type_(x.type_, f, this),
      epsilon_(x.epsilon_, f, this), sigma_(x.sigma_, f, this) {}

CuboidType::CuboidType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), position_(this), velocity_(this), size_(this),
      distance_(this), mass_(this), type_(this), epsilon_(this), sigma_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void CuboidType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // position
        //
        if (n.name() == "position" && n.namespace_().empty()) {
            ::std::unique_ptr<PositionType> r(PositionTraits::create(i, f, this));

            if (!position_.present()) {
                this->position_.set(::std::move(r));
                continue;
            }
        }

        // velocity
        //
        if (n.name() == "velocity" && n.namespace_().empty()) {
            ::std::unique_ptr<VelocityType> r(VelocityTraits::create(i, f, this));

            if (!velocity_.present()) {
                this->velocity_.set(::std::move(r));
                continue;
            }
        }

        // size
        //
        if (n.name() == "size" && n.namespace_().empty()) {
            ::std::unique_ptr<SizeType> r(SizeTraits::create(i, f, this));

            if (!size_.present()) {
                this->size_.set(::std::move(r));
                continue;
            }
        }

        // distance
        //
        if (n.name() == "distance" && n.namespace_().empty()) {
            if (!distance_.present()) {
                this->distance_.set(DistanceTraits::create(i, f, this));
                continue;
            }
        }

        // mass
        //
        if (n.name() == "mass" && n.namespace_().empty()) {
            if (!mass_.present()) {
                this->mass_.set(MassTraits::create(i, f, this));
                continue;
            }
        }

        // type
        //
        if (n.name() == "type" && n.namespace_().empty()) {
            if (!this->type_) {
                this->type_.set(TypeTraits::create(i, f, this));
                continue;
            }
        }

        // epsilon
        //
        if (n.name() == "epsilon" && n.namespace_().empty()) {
            if (!this->epsilon_) {
                this->epsilon_.set(EpsilonTraits::create(i, f, this));
                continue;
            }
        }

        // sigma
        //
        if (n.name() == "sigma" && n.namespace_().empty()) {
            if (!this->sigma_) {
                this->sigma_.set(SigmaTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!position_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("position", "");
    }

    if (!velocity_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
    }

    if (!size_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("size", "");
    }

    if (!distance_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("distance", "");
    }

    if (!mass_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("mass", "");
    }
}

CuboidType *CuboidType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class CuboidType(*this, f, c);
}

CuboidType &CuboidType::operator=(const CuboidType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->position_ = x.position_;
        this->velocity_ = x.velocity_;
        this->size_ = x.size_;
        this->distance_ = x.distance_;
        this->mass_ = x.mass_;
        this->type_ = x.type_;
        this->epsilon_ = x.epsilon_;
        this->sigma_ = x.sigma_;
    }

    return *this;
}

CuboidType::~CuboidType() {}

// ParticleType
//

ParticleType::ParticleType(const PositionType &position, const VelocityType &velocity, const MassType &mass)
    : ::xml_schema::Type(), position_(position, this), velocity_(velocity, this), force_(this), oldForce_(this),
      mass_(mass, this), type_(this), epsilon_(this), sigma_(this), cellIndex_(this) {}

ParticleType::ParticleType(::std::unique_ptr<PositionType> position, ::std::unique_ptr<VelocityType> velocity,
                           const MassType &mass)
    : ::xml_schema::Type(), position_(std::move(position), this), velocity_(std::move(velocity), this), force_(this),
      oldForce_(this), mass_(mass, this), type_(this), epsilon_(this), sigma_(this), cellIndex_(this) {}

ParticleType::ParticleType(const ParticleType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), position_(x.position_, f, this), velocity_(x.velocity_, f, this),
      force_(x.force_, f, this), oldForce_(x.oldForce_, f, this), mass_(x.mass_, f, this), type_(x.type_, f, this),
      epsilon_(x.epsilon_, f, this), sigma_(x.sigma_, f, this), cellIndex_(x.cellIndex_, f, this) {}

ParticleType::ParticleType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), position_(this), velocity_(this), force_(this),
      oldForce_(this), mass_(this), type_(this), epsilon_(this), sigma_(this), cellIndex_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void ParticleType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // position
        //
        if (n.name() == "position" && n.namespace_().empty()) {
            ::std::unique_ptr<PositionType> r(PositionTraits::create(i, f, this));

            if (!position_.present()) {
                this->position_.set(::std::move(r));
                continue;
            }
        }

        // velocity
        //
        if (n.name() == "velocity" && n.namespace_().empty()) {
            ::std::unique_ptr<VelocityType> r(VelocityTraits::create(i, f, this));

            if (!velocity_.present()) {
                this->velocity_.set(::std::move(r));
                continue;
            }
        }

        // force
        //
        if (n.name() == "force" && n.namespace_().empty()) {
            ::std::unique_ptr<ForceType> r(ForceTraits::create(i, f, this));

            if (!this->force_) {
                this->force_.set(::std::move(r));
                continue;
            }
        }

        // oldForce
        //
        if (n.name() == "oldForce" && n.namespace_().empty()) {
            ::std::unique_ptr<OldForceType> r(OldForceTraits::create(i, f, this));

            if (!this->oldForce_) {
                this->oldForce_.set(::std::move(r));
                continue;
            }
        }

        // mass
        //
        if (n.name() == "mass" && n.namespace_().empty()) {
            if (!mass_.present()) {
                this->mass_.set(MassTraits::create(i, f, this));
                continue;
            }
        }

        // type
        //
        if (n.name() == "type" && n.namespace_().empty()) {
            if (!this->type_) {
                this->type_.set(TypeTraits::create(i, f, this));
                continue;
            }
        }

        // epsilon
        //
        if (n.name() == "epsilon" && n.namespace_().empty()) {
            if (!this->epsilon_) {
                this->epsilon_.set(EpsilonTraits::create(i, f, this));
                continue;
            }
        }

        // sigma
        //
        if (n.name() == "sigma" && n.namespace_().empty()) {
            if (!this->sigma_) {
                this->sigma_.set(SigmaTraits::create(i, f, this));
                continue;
            }
        }

        // cellIndex
        //
        if (n.name() == "cellIndex" && n.namespace_().empty()) {
            if (!this->cellIndex_) {
                this->cellIndex_.set(CellIndexTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!position_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("position", "");
    }

    if (!velocity_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
    }

    if (!mass_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("mass", "");
    }
}

ParticleType *ParticleType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class ParticleType(*this, f, c);
}

ParticleType &ParticleType::operator=(const ParticleType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->position_ = x.position_;
        this->velocity_ = x.velocity_;
        this->force_ = x.force_;
        this->oldForce_ = x.oldForce_;
        this->mass_ = x.mass_;
        this->type_ = x.type_;
        this->epsilon_ = x.epsilon_;
        this->sigma_ = x.sigma_;
        this->cellIndex_ = x.cellIndex_;
    }

    return *this;
}

ParticleType::~ParticleType() {}

// DiscType
//

DiscType::DiscType(const PositionType &position, const VelocityType &velocity, const RadiusType &radius,
                   const DistanceType &distance, const MassType &mass)
    : ::xml_schema::Type(), position_(position, this), velocity_(velocity, this), radius_(radius, this),
      distance_(distance, this), mass_(mass, this), type_(this), epsilon_(this), sigma_(this) {}

DiscType::DiscType(::std::unique_ptr<PositionType> position, ::std::unique_ptr<VelocityType> velocity,
                   const RadiusType &radius, const DistanceType &distance, const MassType &mass)
    : ::xml_schema::Type(), position_(std::move(position), this), velocity_(std::move(velocity), this),
      radius_(radius, this), distance_(distance, this), mass_(mass, this), type_(this), epsilon_(this), sigma_(this) {}

DiscType::DiscType(const DiscType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), position_(x.position_, f, this), velocity_(x.velocity_, f, this),
      radius_(x.radius_, f, this), distance_(x.distance_, f, this), mass_(x.mass_, f, this), type_(x.type_, f, this),
      epsilon_(x.epsilon_, f, this), sigma_(x.sigma_, f, this) {}

DiscType::DiscType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), position_(this), velocity_(this), radius_(this),
      distance_(this), mass_(this), type_(this), epsilon_(this), sigma_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void DiscType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // position
        //
        if (n.name() == "position" && n.namespace_().empty()) {
            ::std::unique_ptr<PositionType> r(PositionTraits::create(i, f, this));

            if (!position_.present()) {
                this->position_.set(::std::move(r));
                continue;
            }
        }

        // velocity
        //
        if (n.name() == "velocity" && n.namespace_().empty()) {
            ::std::unique_ptr<VelocityType> r(VelocityTraits::create(i, f, this));

            if (!velocity_.present()) {
                this->velocity_.set(::std::move(r));
                continue;
            }
        }

        // radius
        //
        if (n.name() == "radius" && n.namespace_().empty()) {
            if (!radius_.present()) {
                this->radius_.set(RadiusTraits::create(i, f, this));
                continue;
            }
        }

        // distance
        //
        if (n.name() == "distance" && n.namespace_().empty()) {
            if (!distance_.present()) {
                this->distance_.set(DistanceTraits::create(i, f, this));
                continue;
            }
        }

        // mass
        //
        if (n.name() == "mass" && n.namespace_().empty()) {
            if (!mass_.present()) {
                this->mass_.set(MassTraits::create(i, f, this));
                continue;
            }
        }

        // type
        //
        if (n.name() == "type" && n.namespace_().empty()) {
            if (!this->type_) {
                this->type_.set(TypeTraits::create(i, f, this));
                continue;
            }
        }

        // epsilon
        //
        if (n.name() == "epsilon" && n.namespace_().empty()) {
            if (!this->epsilon_) {
                this->epsilon_.set(EpsilonTraits::create(i, f, this));
                continue;
            }
        }

        // sigma
        //
        if (n.name() == "sigma" && n.namespace_().empty()) {
            if (!this->sigma_) {
                this->sigma_.set(SigmaTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!position_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("position", "");
    }

    if (!velocity_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
    }

    if (!radius_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("radius", "");
    }

    if (!distance_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("distance", "");
    }

    if (!mass_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("mass", "");
    }
}

DiscType *DiscType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class DiscType(*this, f, c);
}

DiscType &DiscType::operator=(const DiscType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->position_ = x.position_;
        this->velocity_ = x.velocity_;
        this->radius_ = x.radius_;
        this->distance_ = x.distance_;
        this->mass_ = x.mass_;
        this->type_ = x.type_;
        this->epsilon_ = x.epsilon_;
        this->sigma_ = x.sigma_;
    }

    return *this;
}

DiscType::~DiscType() {}

// ObjectsType
//

ObjectsType::ObjectsType() : ::xml_schema::Type(), cuboid_(this), particle_(this), disc_(this) {}

ObjectsType::ObjectsType(const ObjectsType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), cuboid_(x.cuboid_, f, this), particle_(x.particle_, f, this),
      disc_(x.disc_, f, this) {}

ObjectsType::ObjectsType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), cuboid_(this), particle_(this), disc_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void ObjectsType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // cuboid
        //
        if (n.name() == "cuboid" && n.namespace_().empty()) {
            ::std::unique_ptr<CuboidType> r(CuboidTraits::create(i, f, this));

            this->cuboid_.push_back(::std::move(r));
            continue;
        }

        // particle
        //
        if (n.name() == "particle" && n.namespace_().empty()) {
            ::std::unique_ptr<ParticleType> r(ParticleTraits::create(i, f, this));

            this->particle_.push_back(::std::move(r));
            continue;
        }

        // disc
        //
        if (n.name() == "disc" && n.namespace_().empty()) {
            ::std::unique_ptr<DiscType> r(DiscTraits::create(i, f, this));

            this->disc_.push_back(::std::move(r));
            continue;
        }

        break;
    }
}

ObjectsType *ObjectsType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class ObjectsType(*this, f, c);
}

ObjectsType &ObjectsType::operator=(const ObjectsType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->cuboid_ = x.cuboid_;
        this->particle_ = x.particle_;
        this->disc_ = x.disc_;
    }

    return *this;
}

ObjectsType::~ObjectsType() {}

// SimType
//

SimType::SimType(const TypeType &type, const ObjectsType &objects)
    : ::xml_schema::Type(), args_(this), type_(type, this), linkedCells_(this), objects_(objects, this),
      totalParticles_(this) {}

SimType::SimType(const TypeType &type, ::std::unique_ptr<ObjectsType> objects)
    : ::xml_schema::Type(), args_(this), type_(type, this), linkedCells_(this), objects_(std::move(objects), this),
      totalParticles_(this) {}

SimType::SimType(const SimType &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), args_(x.args_, f, this), type_(x.type_, f, this),
      linkedCells_(x.linkedCells_, f, this), objects_(x.objects_, f, this),
      totalParticles_(x.totalParticles_, f, this) {}

SimType::SimType(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), args_(this), type_(this), linkedCells_(this),
      objects_(this), totalParticles_(this) {
    if ((f & ::xml_schema::Flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void SimType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement &i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // args
        //
        if (n.name() == "args" && n.namespace_().empty()) {
            ::std::unique_ptr<ArgsType> r(ArgsTraits::create(i, f, this));

            if (!this->args_) {
                this->args_.set(::std::move(r));
                continue;
            }
        }

        // type
        //
        if (n.name() == "type" && n.namespace_().empty()) {
            ::std::unique_ptr<TypeType> r(TypeTraits::create(i, f, this));

            if (!type_.present()) {
                this->type_.set(::std::move(r));
                continue;
            }
        }

        // linkedCells
        //
        if (n.name() == "linkedCells" && n.namespace_().empty()) {
            if (!this->linkedCells_) {
                this->linkedCells_.set(LinkedCellsTraits::create(i, f, this));
                continue;
            }
        }

        // objects
        //
        if (n.name() == "objects" && n.namespace_().empty()) {
            ::std::unique_ptr<ObjectsType> r(ObjectsTraits::create(i, f, this));

            if (!objects_.present()) {
                this->objects_.set(::std::move(r));
                continue;
            }
        }

        // totalParticles
        //
        if (n.name() == "totalParticles" && n.namespace_().empty()) {
            if (!this->totalParticles_) {
                this->totalParticles_.set(TotalParticlesTraits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!type_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("type", "");
    }

    if (!objects_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("objects", "");
    }
}

SimType *SimType::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
    return new class SimType(*this, f, c);
}

SimType &SimType::operator=(const SimType &x) {
    if (this != &x) {
        static_cast<::xml_schema::Type &>(*this) = x;
        this->args_ = x.args_;
        this->type_ = x.type_;
        this->linkedCells_ = x.linkedCells_;
        this->objects_ = x.objects_;
        this->totalParticles_ = x.totalParticles_;
    }

    return *this;
}

SimType::~SimType() {}

#include <istream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/sax/std-input-source.hxx>

::std::unique_ptr<::SimType> sim(const ::std::string &u, ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0,
                                        (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler<char> h;

    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

    h.throw_if_failed<::xsd::cxx::tree::parsing<char>>();

    return ::std::unique_ptr<::SimType>(::sim(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::SimType> sim(const ::std::string &u, ::xml_schema::ErrorHandler &h, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0,
                                        (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr<::SimType>(::sim(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::SimType> sim(const ::std::string &u, ::xercesc::DOMErrorHandler &h, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr<::SimType>(::sim(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::SimType> sim(::std::istream &is, ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0,
                                        (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::sim(isrc, f, p);
}

::std::unique_ptr<::SimType> sim(::std::istream &is, ::xml_schema::ErrorHandler &h, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0,
                                        (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::sim(isrc, h, f, p);
}

::std::unique_ptr<::SimType> sim(::std::istream &is, ::xercesc::DOMErrorHandler &h, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::sim(isrc, h, f, p);
}

::std::unique_ptr<::SimType> sim(::std::istream &is, const ::std::string &sid, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0,
                                        (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::sim(isrc, f, p);
}

::std::unique_ptr<::SimType> sim(::std::istream &is, const ::std::string &sid, ::xml_schema::ErrorHandler &h,
                                 ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0,
                                        (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::sim(isrc, h, f, p);
}

::std::unique_ptr<::SimType> sim(::std::istream &is, const ::std::string &sid, ::xercesc::DOMErrorHandler &h,
                                 ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::sim(isrc, h, f, p);
}

::std::unique_ptr<::SimType> sim(::xercesc::InputSource &i, ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
    ::xsd::cxx::tree::error_handler<char> h;

    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

    h.throw_if_failed<::xsd::cxx::tree::parsing<char>>();

    return ::std::unique_ptr<::SimType>(::sim(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::SimType> sim(::xercesc::InputSource &i, ::xml_schema::ErrorHandler &h, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr<::SimType>(::sim(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::SimType> sim(::xercesc::InputSource &i, ::xercesc::DOMErrorHandler &h, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr<::SimType>(::sim(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::SimType> sim(const ::xercesc::DOMDocument &doc, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &p) {
    if (f & ::xml_schema::Flags::keep_dom) {
        ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(
            static_cast<::xercesc::DOMDocument *>(doc.cloneNode(true)));

        return ::std::unique_ptr<::SimType>(::sim(std::move(d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement &e(*doc.getDocumentElement());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

    if (n.name() == "sim" && n.namespace_() == "") {
        ::std::unique_ptr<::SimType> r(::xsd::cxx::tree::traits<::SimType, char>::create(e, f, 0));
        return r;
    }

    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "sim", "");
}

::std::unique_ptr<::SimType> sim(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d, ::xml_schema::Flags f,
                                 const ::xml_schema::Properties &) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> c(
        ((f & ::xml_schema::Flags::keep_dom) && !(f & ::xml_schema::Flags::own_dom))
            ? static_cast<::xercesc::DOMDocument *>(d->cloneNode(true))
            : 0);

    ::xercesc::DOMDocument &doc(c.get() ? *c : *d);
    const ::xercesc::DOMElement &e(*doc.getDocumentElement());

    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

    if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData(::xml_schema::dom::treeNodeKey, (c.get() ? &c : &d), 0);

    if (n.name() == "sim" && n.namespace_() == "") {
        ::std::unique_ptr<::SimType> r(::xsd::cxx::tree::traits<::SimType, char>::create(e, f, 0));
        return r;
    }

    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "sim", "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void sim(::std::ostream &o, const ::SimType &s, const ::xml_schema::NamespaceInfomap &m, const ::std::string &e,
         ::xml_schema::Flags f) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::sim(s, m, f));

    ::xsd::cxx::tree::error_handler<char> h;

    ::xsd::cxx::xml::dom::ostream_format_target t(o);
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        h.throw_if_failed<::xsd::cxx::tree::serialization<char>>();
    }
}

void sim(::std::ostream &o, const ::SimType &s, ::xml_schema::ErrorHandler &h, const ::xml_schema::NamespaceInfomap &m,
         const ::std::string &e, ::xml_schema::Flags f) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::sim(s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t(o);
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void sim(::std::ostream &o, const ::SimType &s, ::xercesc::DOMErrorHandler &h, const ::xml_schema::NamespaceInfomap &m,
         const ::std::string &e, ::xml_schema::Flags f) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::sim(s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t(o);
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void sim(::xercesc::XMLFormatTarget &t, const ::SimType &s, const ::xml_schema::NamespaceInfomap &m,
         const ::std::string &e, ::xml_schema::Flags f) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::sim(s, m, f));

    ::xsd::cxx::tree::error_handler<char> h;

    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        h.throw_if_failed<::xsd::cxx::tree::serialization<char>>();
    }
}

void sim(::xercesc::XMLFormatTarget &t, const ::SimType &s, ::xml_schema::ErrorHandler &h,
         const ::xml_schema::NamespaceInfomap &m, const ::std::string &e, ::xml_schema::Flags f) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::sim(s, m, f));
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void sim(::xercesc::XMLFormatTarget &t, const ::SimType &s, ::xercesc::DOMErrorHandler &h,
         const ::xml_schema::NamespaceInfomap &m, const ::std::string &e, ::xml_schema::Flags f) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::sim(s, m, f));
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void sim(::xercesc::DOMDocument &d, const ::SimType &s, ::xml_schema::Flags) {
    ::xercesc::DOMElement &e(*d.getDocumentElement());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

    if (n.name() == "sim" && n.namespace_() == "") {
        e << s;
    } else {
        throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "sim", "");
    }
}

::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> sim(const ::SimType &s, const ::xml_schema::NamespaceInfomap &m,
                                                          ::xml_schema::Flags f) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::serialize<char>("sim", "", m, f));

    ::sim(*d, s, f);
    return d;
}

void operator<<(::xercesc::DOMElement &e, const ArgsType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // startTime
    //
    if (i.startTime()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("startTime", e));

        s << ::xml_schema::AsDouble(*i.startTime());
    }

    // endTime
    //
    if (i.endTime()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("endTime", e));

        s << ::xml_schema::AsDouble(*i.endTime());
    }

    // delta_t
    //
    if (i.delta_t()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("delta_t", e));

        s << ::xml_schema::AsDouble(*i.delta_t());
    }

    // frequency
    //
    if (i.frequency()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("frequency", e));

        s << *i.frequency();
    }

    // basename
    //
    if (i.basename()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("basename", e));

        s << *i.basename();
    }

    // output
    //
    if (i.output()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("output", e));

        s << *i.output();
    }

    // domainSize
    //
    if (i.domainSize()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("domainSize", e));

        s << *i.domainSize();
    }

    // cutoffRadius
    //
    if (i.cutoffRadius()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("cutoffRadius", e));

        s << ::xml_schema::AsDouble(*i.cutoffRadius());
    }

    // bdConditions
    //
    if (i.bdConditions()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("bdConditions", e));

        s << *i.bdConditions();
    }

    // gravity
    //
    if (i.gravity()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("gravity", e));

        s << ::xml_schema::AsDouble(*i.gravity());
    }
}

void operator<<(::xercesc::DOMElement &e, const BdConditionsType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // n
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("n", e));

        s << i.n();
    }

    // s
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("s", e));

        s << i.s();
    }

    // w
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("w", e));

        s << i.w();
    }

    // e
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("e", e));

        s << i.e();
    }

    // a
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("a", e));

        s << i.a();
    }

    // b
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("b", e));

        s << i.b();
    }
}

void operator<<(::xercesc::DOMElement &e, const BoundaryConditionType &i) {
    e << static_cast<const ::xml_schema::String &>(i);
}

void operator<<(::xercesc::DOMAttr &a, const BoundaryConditionType &i) {
    a << static_cast<const ::xml_schema::String &>(i);
}

void operator<<(::xml_schema::ListStream &l, const BoundaryConditionType &i) {
    l << static_cast<const ::xml_schema::String &>(i);
}

void operator<<(::xercesc::DOMElement &e, const PositionType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // x
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("x", e));

        s << ::xml_schema::AsDouble(i.x());
    }

    // y
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("y", e));

        s << ::xml_schema::AsDouble(i.y());
    }

    // z
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("z", e));

        s << ::xml_schema::AsDouble(i.z());
    }
}

void operator<<(::xercesc::DOMElement &e, const VelocityType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // x
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("x", e));

        s << ::xml_schema::AsDouble(i.x());
    }

    // y
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("y", e));

        s << ::xml_schema::AsDouble(i.y());
    }

    // z
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("z", e));

        s << ::xml_schema::AsDouble(i.z());
    }
}

void operator<<(::xercesc::DOMElement &e, const ForceType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // x
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("x", e));

        s << ::xml_schema::AsDouble(i.x());
    }

    // y
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("y", e));

        s << ::xml_schema::AsDouble(i.y());
    }

    // z
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("z", e));

        s << ::xml_schema::AsDouble(i.z());
    }
}

void operator<<(::xercesc::DOMElement &e, const SizeType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // x
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("x", e));

        s << ::xml_schema::AsDouble(i.x());
    }

    // y
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("y", e));

        s << ::xml_schema::AsDouble(i.y());
    }

    // z
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("z", e));

        s << ::xml_schema::AsDouble(i.z());
    }
}

void operator<<(::xercesc::DOMElement &e, const CuboidType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // position
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("position", e));

        s << i.position();
    }

    // velocity
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("velocity", e));

        s << i.velocity();
    }

    // size
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("size", e));

        s << i.size();
    }

    // distance
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("distance", e));

        s << ::xml_schema::AsDouble(i.distance());
    }

    // mass
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("mass", e));

        s << ::xml_schema::AsDouble(i.mass());
    }

    // type
    //
    if (i.type()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("type", e));

        s << *i.type();
    }

    // epsilon
    //
    if (i.epsilon()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("epsilon", e));

        s << ::xml_schema::AsDouble(*i.epsilon());
    }

    // sigma
    //
    if (i.sigma()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sigma", e));

        s << ::xml_schema::AsDouble(*i.sigma());
    }
}

void operator<<(::xercesc::DOMElement &e, const ParticleType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // position
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("position", e));

        s << i.position();
    }

    // velocity
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("velocity", e));

        s << i.velocity();
    }

    // force
    //
    if (i.force()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("force", e));

        s << *i.force();
    }

    // oldForce
    //
    if (i.oldForce()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("oldForce", e));

        s << *i.oldForce();
    }

    // mass
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("mass", e));

        s << ::xml_schema::AsDouble(i.mass());
    }

    // type
    //
    if (i.type()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("type", e));

        s << *i.type();
    }

    // epsilon
    //
    if (i.epsilon()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("epsilon", e));

        s << ::xml_schema::AsDouble(*i.epsilon());
    }

    // sigma
    //
    if (i.sigma()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sigma", e));

        s << ::xml_schema::AsDouble(*i.sigma());
    }

    // cellIndex
    //
    if (i.cellIndex()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("cellIndex", e));

        s << *i.cellIndex();
    }
}

void operator<<(::xercesc::DOMElement &e, const DiscType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // position
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("position", e));

        s << i.position();
    }

    // velocity
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("velocity", e));

        s << i.velocity();
    }

    // radius
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("radius", e));

        s << i.radius();
    }

    // distance
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("distance", e));

        s << ::xml_schema::AsDouble(i.distance());
    }

    // mass
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("mass", e));

        s << ::xml_schema::AsDouble(i.mass());
    }

    // type
    //
    if (i.type()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("type", e));

        s << *i.type();
    }

    // epsilon
    //
    if (i.epsilon()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("epsilon", e));

        s << ::xml_schema::AsDouble(*i.epsilon());
    }

    // sigma
    //
    if (i.sigma()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("sigma", e));

        s << ::xml_schema::AsDouble(*i.sigma());
    }
}

void operator<<(::xercesc::DOMElement &e, const ObjectsType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // cuboid
    //
    for (ObjectsType::CuboidConstIterator b(i.cuboid().begin()), n(i.cuboid().end()); b != n; ++b) {
        const ObjectsType::CuboidType &x(*b);

        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("cuboid", e));

        s << x;
    }

    // particle
    //
    for (ObjectsType::ParticleConstIterator b(i.particle().begin()), n(i.particle().end()); b != n; ++b) {
        const ObjectsType::ParticleType &x(*b);

        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("particle", e));

        s << x;
    }

    // disc
    //
    for (ObjectsType::DiscConstIterator b(i.disc().begin()), n(i.disc().end()); b != n; ++b) {
        const ObjectsType::DiscType &x(*b);

        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("disc", e));

        s << x;
    }
}

void operator<<(::xercesc::DOMElement &e, const SimType &i) {
    e << static_cast<const ::xml_schema::Type &>(i);

    // args
    //
    if (i.args()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("args", e));

        s << *i.args();
    }

    // type
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("type", e));

        s << i.type();
    }

    // linkedCells
    //
    if (i.linkedCells()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("linkedCells", e));

        s << *i.linkedCells();
    }

    // objects
    //
    {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("objects", e));

        s << i.objects();
    }

    // totalParticles
    //
    if (i.totalParticles()) {
        ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("totalParticles", e));

        s << *i.totalParticles();
    }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
